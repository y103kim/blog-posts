---
layout: post
category: languages
title: Programming in scala 정리 (2)
tags: [Scala]
---

<style>
  body{counter-reset: section 10}
  div.post-body h1:before{
    counter-increment: section;
    content: counter(section) ". ";
  }
</style>

11장부터 이어서 계속

- 01~10장: <https://doocong.com/languages/scala-1/>
- 11~20장: <https://doocong.com/languages/scala-2/>

# Scala's Hirarchy

- `Any`: `abstract class`, 모든 타입의 부모 타입
  - `==`, `!=`, `equals`, `hashCode`, `toString`: 공통 함수들
- `AnyVal`: `abstract class`, 모든 vaule 타입의 부모 타입
  - value 타입은 비교시 값을 직접 비교함
  - value 타입은 `new`로 인스턴스 생성 못함
- `AnyRef`: `class`, 모든 ref 타입의 부모 타입
  - ref 타입은 비교시 주소를 비교함
- `Null`: `abstract class`, 모든 ref 타입의 자식 타입
- `null`: `object`, `Null`의 유일한 인스턴스, value 타입에 대입 불가
- `Nothing`: `abstract class`, 모든 타입의 자식 타입, 인스턴스 없음
- `Unit`: `abstract class`, Vaule 타입임, 함수의 리턴이 없음을 나타냄
  - 모든 객체가 `Unit`으로 암시적으로 변환될 수 있으며, 이 경우 데이터가 삭제됨
- `None`: `object`, nullable한 비어있는 값을 리턴할 때 사용됨

### Value type

- 컴파일러가 자바 바이트코드로 변환시 알아서 처리
- 대부분 primitve로 처리해서 효율성 추구
- 필요할 때는 `java.lang.Integer`로 박싱됨
  - 확장 함수를 부르거나
  - `Any`로 대입될때
- 동등성은 값을 기준으로 계산됨

# Traits

- `class`와 거의 동일한 기능을 할 수 있음
  - 메소드, 필드 선언 등등
- java8의 interface와 매우 유사하다.
  - 디폴트 메소드를 허용하며
  - rich interface를 추구한다.
- 중요한 기능들
  - 다중상속: `extends`, `with`
  - 인스턴스에 붙이기 가능
  - 동적 super call 바인딩
  - Stackable
- 한가지 단점
  - 외부에서 사용 불가능, 밖에 제공할 목적이면 class 써야함

|                        |       Traits       |  Abstract Class  |
|:----------------------:|:------------------:|:----------------:|
|  multiple inheritance  |       support      |    not support   |
|     add to instance    |      possible      |    impossible    |
| constructor parameters | impossible to have | possible to have |
|   Java interoperable   |  not interoperable |   interoperable  |
|   super call binding   |       dynamic      |      static      |
|        Stackable       |      stackable     |   not stackable  |


### Stackable Modification

- 다중 상속이 가능
- 다중 상속으로 인한 함수 이름 충돌시, 기본적으로 컴파일 에러가 남
- 같은 `class` 를 상속받는 경우
  - 같은 이름의 함수를 확장할 수 있음
  - 더 나중(오른쪽)에 붙인 `trait`의 함수가 먼저 호출됨
  - `super`는 왼쪽 `trait`의 함수를 지칭함
- `abstract class`를 상속받고, 구현이 존재하지 않는 함수가 충돌할 경우
  - `abstract override`로 함수 선언해야함
  - 이 경우에도 `super`를 쓸 수 있음
  - 그리고 함수가 런타임에 바인딩됨

```scala
// Example 1: compile ok
class X
class Y
object O extends X with Y

// Example 2: function name conflict
trait X { def f() = print("X") }
trait Y { def f() = print("Y") }
object O extends X with Y // error

// Example 3: ok with base class
class Base { def f() = print("B") }
trait X extends Base { override def f() = print("X") }
trait Y extends Base { override def f() = print("Y") }
object O extends X with Y
O.f() // output: Y

// Example 4: cascade super call
class Base { def f() = print("B") }
trait X extends Base { override def f() = { print("X"); super.f() } }
trait Y extends Base { override def f() = { print("Y"); super.f() } }
object O extends X with Y
O.f() // output: YXB

// Example 5: abstract override function
abstract class Base { def f(): Unit }
class I extends Base { def f() = print("I") }
trait X extends Base { abstract override def f() = { print("X"); super.f() } }
trait Y extends Base { abstract override def f() = { print("Y"); super.f() } }
val x = new I with X with Y
x.f() // output: YXI
```

### Linearliztion

- 다중상속으로 얽히 Trait의 호출 관계를 풀어내는 과정
- 호출시에는 오른쪽에서 왼쪽으로
- 선형화로 순선 정할시에는 왼쪽에서 오른쪽으로
  - 앞에서 이미 탐색한 지점을 만날때까지 루트로부터 최단경로를 앞에다가 붙여주면 됨

```scala
class B { def f() = print("B") }
trait X extends B { override def f() = { print("X"); super.f() } }
trait Y extends B { override def f() = { print("Y"); super.f() } }
trait T extends X { override def f() = { print("T"); super.f() } }
trait U extends X with Y { override def f() = { print("U"); super.f() } }

(new B with T).f() // TYB
  // B: B
  // T: T -> Y -> B

(new B with Y with T).f() // TYB
  // B: B
  // Y: Y -> B
  // T: T -> Y -> B

(new B with T with Y).f() // TYB
  // B: B
  // T: T -> Y -> B
  // Y: T -> Y -> B

(new B with U).f() // UYXB
  // B   : B
  // U(X): X -> B
  // U(Y): Y -> X -> B
  // U   : U -> Y -> X -> B

(new B with T with U).f() // UXTYB
  // B   : B
  // T   : T -> Y -> B
  // U(X): X -> T -> Y -> B
  // U(Y): X -> T -> Y -> B
  // U   : U -> X -> T -> Y -> B
```

# Packages and Imports

### package

- 자바랑 똑같이 제일 앞줄에 패키지 써주면 됨
- 중첩 형식 가능
  - C++의 namespace처럼 쓸 수 있고, 스코프를 공유함
  - 즉 중첩되어 있을때는 루트부터 경로를 쓰지 않아도 됨
  - `_root_`로 최 외곽 패키지에도 접근 가능

### import

- 파이썬처럼 on-demand로 import가 가능
- 와일드카드 혹은 선택적 임포트
  - `import A._` 패키지 내의 모든것 가져오기
  - `import A.{B, C}` 선택적으로 가져오기
  - `import A.{B => D}` 이름 바꿔서 선택적으로 가져오기
  - `import A.{B => D, _}` 이름 바꾸고, 전체 다 가져오기
  - `import A.{B => _, _}` `B`는 제외하고 다 가져오기
- 3개 패키지는 암시적으로 import됨
  - `java.lang._`, `scala._`, `Predef._`

### Access Modifier

- 블록단위의 스코프를 가짐
- 블록 내에서 변수를 재정의 할 수 있음(like C++, not-like Java)
  - 인터프리터 내에서는 항상 재정의 가능
- 클래스 변수의 접근 제한자 별 스코프는 아래 표와 같음
  - top-level private과 protected는 같은 효과를 냄
  - [참고 블로그](https://www.jesperdj.com/2016/01/08/scala-access-modifiers-and-qualifiers-in-detail/)
  - `protected`는 java 와 효과범위가 다름
- `private[X]`로 접근 가능 범위를 제한할 수 있음
  - X는 패키지, 클래스 `this`가 될 수 있음

|      Modifier     | Class | Companion | Subclass | Package | World |
|:-----------------:|:-----:|:---------:|:--------:|:-------:|:-----:|
|    no modifier    |   O   |     O     |     O    |    O    |   O   |
|     protected     |   O   |     O     |     O    |    X    |   X   |
|      private      |   O   |     O     |     X    |    X    |   X   |
| top-level private |   O   |     O     |     O    |    O    |   X   |


# Assertions and Unit Testing

- 생략

# Case Classes and Pattern Matching

# Working with Lists

# Collections

# Statful Objects

# Type Parameterization

# Abstract Member

# Implicit Conversions and Parameters

# Implementing Lists

# For Expressions Revisited

# Extractors

# Annotations

# Objects As Modules

# Object Equality

# Combining Scala and Java

# Actor and Concurrency

# Combinator Parsing

