---
layout: post
category: languages
title: Programming in scala 정리 (1)
tags: [Scala]
---

<style>
  body{counter-reset: section}
  div.post-body h1:before{
    counter-increment: section;
    content: counter(section) ". ";
  }
</style>

Scala 3를 익히기 위해선, 먼저 Scala 2를 알아야 할 것 같다. 관련 책 한권을 정리해본다.

- 01~10장: <https://doocong.com/languages/scala-1/>
- 11~20장: <https://doocong.com/languages/scala-2/>

# A Scalable Language

### scala를 써야하는 7가지 이유

1. Scala is scalable
  - 확장이 용이, 커스텀 타입을 빌트인 처럼 쓸 수 있다.
  - 연산자 함수 등을 커스텀해, DSL을 만들기에도 용이하다. 
2. Scala is OOP
  - Pure OOP = 모든 요소는 객체(값, 함수, 타입 포함)
  - Powerful composition feature = `trait`
3. Scala is FP
  - 함수을 first-class value로 취급한다.
  - 값의 변경 대신, 입출력의 매핑에 집중한다.
  - 사이드 이펙트 없음 = referentially transparent
4. Scala is compatible
  - interoperability with Java
  - implicit conversion을 통한 Java 라이브러리 강화
5. Scala is concise
  - less boilerplate, easy to read and understand
  - FP, 확장 가능한 라이브러리로 더 짧게 줄일 수 있음
6. Scala is high-level
  - 메소드를 전달함으로서 제어-추상화 가능
7. Scala is staticically typed
  - 정적 타입의 장점은 살리고, 타입추정으로 verbosity를 줄임

# First Steps in Scala

- 변수 선언
  - 변수 선언시 `val`, `var` 사용, 타입 추정됨
  - `val` = immutable
  - `var` = mutable
  - `def` = lazy (사실은 함수임)
- 함수 선언
  - `def` 로 시작
  - 변수, 파라미터와 타입, 리턴타입 모두 Kotlin과 동일
  - 단 body와 function 선언 사이에 `=`이 들어가야함
  - 한 줄 일 경우 블록 필요 없음
  - 여러 줄 일 경우 `{}` 필요, scala3에서는 indent로 대체됨
- 반복, 조건
  - `while`은 타 언어와 사용법 동일
  - `if` 역시 동일, 추가로 expression으로 사용 가능
  - `for`는 *generator* 포맷으로 사용, immutable yield만 가능

```scala
def max(x: Int, y: Int): Int = {
  if (x > y) x else y
}

for (arg <- args) println(arg)
```

# Next Steps in Scala

### Generics, Array, apply, update

- 제너릭은 대괄호로 표현
  - 타입은 명시하지 않아도 자동으로 추정됨
- `apply`
  - 객체에 대해서 메소드 이름 없이 호출하면 `apply`가 호출됨
  - 인스턴스에 대해서 호출하면, 멤버 `apply`가 호출됨
  - 클래스에 대해서 호출하면, companion object의 `apply`가 호출됨
- `update`
  - 특정 객체에 대한 대입은 update로 치환됨
  - `apply`와 마찬가지로 클래스에 대해서 호출하면, 컴패니언의 update가 호출됨
- infix 호출
  - 인자가 하나인 메소드는 별다른 처리 없이 infix로 쓸 수 있음

```scala
// generic type inference
Array(1,2) == Array[Int](1,2)
Array[Int].apply(1,2,3) // invalid

// calling with non-function is equal to call apply
notFunction(123)
notFunction.apply(123)

// equal can be replaced by update
greetStrings(0) = "Hello"
greetStrings.update(0, "Hello")
```

### List

- Array와 다른점
  - immutable (Array는 mutable)
  - 값 비교 가능 (Array는 reference 비교함)
  - 연결 리스트이므로, random access에 선형시간이 걸림
- 각 노드가 head와 tail을 가지고 이어진 연결리스트
  - `head`나 `tail`은 상수시간에 찾을 수 있다.
- 연산자 메서드 존재
  - `elem :: List` 리스트 가장 앞에 원소를 추가, $O(1)$
  - `List :+ elem` 리스트 뒤에 원소를 추가, $O(N)$
  - `List ::: List` 두 리스트를 이어붙임, $O(N)$
- `Nil`은 빈 리스트

### Tuple

- Array처럼 특별취급 되는 자료구조
- 괄호로 묶어서 선언 가능
- 실제로는 `TupleN` 클래스의 인스턴스
- decomposed binding 가능
- `_1`, `_2` 등으로 접근 가능

### Set, Map

- mutable, immutable 패키지가 나눠져있음, 양자택일 해야함
  - `scala.collection.immutable.HashSet`
  - `scala.collection.mutable.HashSet`
- 기본은 immutable임
- 원소 추가
  - `+=`는 mutable에서만 쓸 수 있음
  - `+`는 둘다 쓸수 있음, immutable에서는 새 Set을 만들어서 리턴
- Map의 경우는 `->` 메서드로 튜플을 만들어 선언, 그냥 튜플 넣어도 됨
  - `Map((1,'a'), (2,'b')) == Map(1->'a', 2->'b')`
- Map, Set 모두 List 처럼 동일성 비교 가능

### Scala style

- 기본적으로는 FP와 OOP 모두 가능하다.
- 필요에 따라서 적합한걸 선택한다.
- 다만 양립 가능한 상황에서는, 최대한 FP를 선택한다.
- FP를 선택한다는 것은, 최대한 `var`없이 코드를 작성하는 것이다.

# Classes and Objects

### Class and members

- 클래스 기본
  - `class` 선언은 자바의 그것과 동일
  - scala3 부터는 파이썬 스타일로 `:`과 indent로 블럭 지정 가능
  - 인스턴스 화 할때는 `new` 사용
  - 멤버로 `val`, `var`, `def`를 가질 수 있음
- `new`와 `apply` 비교
  - `new`와 함께 호출시 명시적 생성자 호출
  - 그냥 호출시 companion object의 `apply`가 호출됨
  - scala3 `apply`가 없으면, 자동으로 `apply`로 `new` 호출됨
- `Unit` 타입
  - 모든 타입객체는 Unit으로 변환 가능
  - `Any`타입 변수에 값을 대입하는것과는 다름
  - Unit으로 변환되면서 데이터가 사라짐
- 세미콜로는 생략해도 됨

### Singleton Objects

- `object` 로 선언, 클래스랑 같은 문법
  - 단 파라미터는 사용 불가능, 정적 속성을 가지므로 당연함
  - 다른 클래스나, trait를 상속 가능
  - 타입으로서는 사용 못함, 즉 부모로서 상속해주는것은 불가능
- Companion object
  - 같은 파일, 같은 이름의 `class`와 `object`가 있으면 companion object임
  - 각자의 `private` 멤버에 접근 가능
  - `class`는 `object`의 private 멤버에 제한없이 접근 가능(마치 정적 멤버처럼)
  - `object`는 **인스턴스**의 private 멤버에 접근 가능

### Scala Application

- 진입점으로 main 함수를 가진 `object`가 존재해야함
- 간단하게 `@main`으로 대체 가능
- 또는 `object XX extends Application` 안에 수행할 코드를 넣을 수도 있음
  - JVM 최적화를 방해할 가능성 있음, 쓰지말 것
- script로 쓰려면 마지막에 expression이 나와야 함

# Basic Types and Operations

### 타입 시스템

- Java와 매칭되는 타입 시스템
- `Byte`, `Short`, `Int`, `Long`, `Float`, `Double`
- `Char`, `String`, `Boolean`
- `Java.lang.Integer` ~ `scala.Int`
- `int` 로 쓰면 `Int`와 같지만 권장되지 않음
- Scala 컴파일러가 primitive로 쓰도록 바이트코드 컴파일 해줌

### 리터럴

- 8진수 존재함, C++이나 Java랑 같음
- Float은 `1.0F`, Long은 `123L`
- 작은따옴표는 문자, 큰따옴표는 문자열
- 문자 작성시 `\101`, `\u0041`로 Ascii, Uni-code 표현 가능
- 여러줄 문자열 `"""`, 여백 제거(`stripMargin`)는 `|`기준으로 자름
- `Symbol`, 동일성이 보장되는 알파벳으로만 구성된 문자열. 성능 상 이점이 있음
  - `'abc` 처럼 리터럴을 사용했으나, Deprecated 됨, `Symbol("abc")`로 쓰자.

### 연산자

- 연산자는 메서드다
  - 타 언어에서 특별히 정의되었던 연산자들 모두 메서드다.
  - 메소드 이름의 자유도가 높다.
  - 그러므로 연산자 이름에도 자유도가 높다.
- Identifier로 쓸 수 있는 문자열이 엄청 많다
  - 둘 이상의 연속된 특수문자도 가능
  - 특수문자와 알파벳, 숫자의 조합도 가능
  - 다음 섹션에서 자세히 설명
- 메소드로 선언한 것들은 연산자처럼 쓸 수 있다.
  - 특히 인자를 한개만 받으면 `infix` 표기로 쓸 수 있다.
  - 인자가 두개 이상이면, `infix`로 쓰되, 뒤쪽을 괄호로 묶어야 한다.
- 단향 연산자
  - 인자가 없으면, postfix unary 연산자로 쓸 수 있다.
  - 전치는 `+-!~` 만 허용, 단 `unary_+` 처럼 선언 필요
- 우선순위
  - 첫 글자로 우선순위 결정됨
  - 그 우선순위 자체는 다른 언어와 거의 유사함
  - `다른특수문자들 */% +- : =! <> & ^ | 알파벳 대입연산 콤마` 순
  - 예외1: `=`로 끝나는 대입 연산자들은 첫 문자에 상관없음
  - 예외2: `:`로 끝나는 연산자는 right to left 로 결합함

# Functional Objects

- Functional object
  - 이 책에서만 쓰는 용어인듯
  - Mutable한 상태를 가지지 않는 객체를 뜻함
- 예제를 통해서 객체 생성 접근해보기
  - 사칙연산 가능한 유리수 객체 만들기

### Constructing Rational number

- Primary Constructor
  - Body가 없으면 block 없이 선언해도 됨
  - body는 primary 생성자 역할을 겸함 (Kotlin과 완전 동일)
  - 함수처럼 파라미터를 받을 수 있음
  - `require` 함수 assert, 위반시 `IllegalArgumentException`
  - `this` = self reference
  - `val`, `var`을 블록 내에 선언해서 필드로 사용
  - `val`, `var`을 붙이면 멤버로서 바로 사용 가능
- Auxiliary Constructor
  - `def this`로 선언
  - 다른 생성자를 꼭 불러야함, 최종적으로는 primary가 불리게 되어 있음
  - Aux-const는 super class의 생성자를 호출할 수 없음 (Primary만 가능)
- 필드 가시성
  - 기본적으로 `public`임
  - `private` 으로 선언해서 사용 가능
- String interpolation
  - `s"$numer/$denom"`

```scala
// class parameter without body
class Rational(n: Int, d: Int)

// class parameter with field, require, method, aux const
class Rational(n: Int, d: Int) {
  require(d != 0)
  private val g = gcd(n.abs, d.abs)
  val numer = n / g
  val denom = d / g

  def this(n: Int) = this(n, 1) // auxiliary constructor

  override def toString = s"$numer/$denom"

  def add(that: Rational): Rational = {
    new Rational(
      numer * that.denom + that.numer * denom,
      denom * that.denom
    )
  }

  private def gcd(a: Int, b: Int): Int =
    if (b == 0) a else gcd(b, a%b)
  
  def * (that: Rational) =
    new Rational(this.numer * that.numer, this.denom * that.denom)
}
```

### Identifier

- 4가지 종류의 Identifier
1. alphanumeric identifier
  - letter 혹은 `_` 로 시작해야함
  - 이후 letter, digit, `_` 가능
  - `$` 는 letter 취급이지만, 예약문자 이기때문에 못씀
  - 카멜 케이스 권장됨
  - `_`는 주의해서 쓸것 뒤쪽 특수문자를 붙여서 식별자로 인식하게함
  - 상수의 경우는 첫문자 대문자 카멜 케이스를 쓰는걸 권장
2. operator identifier
  - letter, digit, `()`, `[]`, `{}`, ``"'`_.;,`` 제외
  - 나머지 모든 ASCII 코드와, Sm/So 유니코드 만으로 구성됨
  - 여러개의 특수문자를 연결해서 연산자처럼 사용 가능
  - 자바 컴파일 시 `$`를 사용해서 표현됨 `:-` = `$colon$minus`
3. mixed identifier
  - 1과 2 모두 사용된 경우
  - 일반적으로는 안쓰이고, `unary_`, 대입연산자, `properties`를 위해 사용됨
4. literal identifier
  - back tick `` ` `` 으로 묶어서 식별자로 사용
  - 대부분의 문자가 가능하고, 예약어도 가능
  - 자바의 함수명이 예약어와 겹칠 때 유용

```scala
val name_: Int = 1 // error "name_:" 가 식별자로 인식됨
val name_ : Int = 1 // ok 이지만 권장하지 않음
```

### 오버로딩과 암시적 변환

- `Rational`을 만들고 `Int`와 곱셈이 되게 하고 싶음
  - `r1 * r2`: `* (r1: Rational, r2: Rational)` 메서드를 만들었음
  - `r1 * 2`: `* (r1: Rational, n: Int)` 메서드 오버로딩 해야함
  - `2 * r1`: 암시적 변환 필요
- 암시적 변환
  - `implict`과 적절한 변환 함수를 선언하면, 자동으로 변환해줌
  - 단 스칼라 3 및 최신 스칼라 2에서는 권장되지 않는 방법임
  - `given`을 쓰는게 바람직함
  - 명시적이지 않은 코드를 양산하므로, 항상 사용에 주의할것

```scala
// Not recommended now, using given / using
implicit def intToRational(x: Int) = new Rational(x)

// scala3 recommended
given Conversion[Int, Rational] = new Rational(_)

// scala3 recommended: full version
given Conversion[Int, Rational] with
  def apply(n: Int): Rational = new Rational(n)
```

# Built-in Control Structures

# Function and Closures

# Composition and Inherithance

# Scala's Hirarchy
