---
layout: post
category: languages
title: Programming in scala 정리
tags: [Scala]
---

<style>
  body{counter-reset: section}
  div.post-body h1:before{
    counter-increment: section;
    content: counter(section) ". ";
  }
</style>

Scala 3를 익히기 위해선, 먼저 Scala 2를 알아야 할 것 같다. 관련 책 한권을 정리해본다.

# A Scalable Language

### scala를 써야하는 7가지 이유

1. Scala is scalable
  - 확장이 용이, 커스텀 타입을 빌트인 처럼 쓸 수 있다.
  - 연산자 함수 등을 커스텀해, DSL을 만들기에도 용이하다. 
2. Scala is OOP
  - Pure OOP = 모든 요소는 객체(값, 함수, 타입 포함)
  - Powerful composition feature = `trait`
3. Scala is FP
  - 함수을 first-class value로 취급한다.
  - 값의 변경 대신, 입출력의 매핑에 집중한다.
  - 사이드 이펙트 없음 = referentially transparent
4. Scala is compatible
  - interoperability with Java
  - implicit conversion을 통한 Java 라이브러리 강화
5. Scala is concise
  - less boilerplate, easy to read and understand
  - FP, 확장 가능한 라이브러리로 더 짧게 줄일 수 있음
6. Scala is high-level
  - 메소드를 전달함으로서 제어-추상화 가능
7. Scala is staticically typed
  - 정적 타입의 장점은 살리고, 타입추정으로 verbosity를 줄임

# First Steps in Scala

- 변수 선언
  - 변수 선언시 `val`, `var` 사용, 타입 추정됨
  - `val` = immutable
  - `var` = mutable
  - `def` = lazy (사실은 함수임)
- 함수 선언
  - `def` 로 시작
  - 변수, 파라미터와 타입, 리턴타입 모두 Kotlin과 동일
  - 단 body와 function 선언 사이에 `=`이 들어가야함
  - 한 줄 일 경우 블록 필요 없음
  - 여러 줄 일 경우 `{}` 필요, scala3에서는 indent로 대체됨
- 반복, 조건
  - `while`은 타 언어와 사용법 동일
  - `if` 역시 동일, 추가로 expression으로 사용 가능
  - `for`는 *generator* 포맷으로 사용, immutable yield만 가능

```scala
def max(x: Int, y: Int): Int = {
  if (x > y) x else y
}

for (arg <- args) println(arg)
```

# Next Steps in Scala

### Generics, Array, apply, update

- 제너릭은 대괄호로 표현
  - 타입은 명시하지 않아도 자동으로 추정됨
- `apply`
  - 객체에 대해서 메소드 이름 없이 호출하면 `apply`가 호출됨
  - 인스턴스에 대해서 호출하면, 멤버 `apply`가 호출됨
  - 클래스에 대해서 호출하면, companion object의 `apply`가 호출됨
- `update`
  - 특정 객체에 대한 대입은 update로 치환됨
  - `apply`와 마찬가지로 클래스에 대해서 호출하면, 컴패니언의 update가 호출됨
- `new`와 `apply`
  - `new`와 함께 호출시 명시적 생성자 호출
  - 그냥 호출시 companion object의 `apply`가 호출됨
  - scala3 `apply`가 없으면, 자동으로 `apply`로 `new` 호출됨
- infix 호출
  - 인자가 하나인 메소드는 별다른 처리 없이 infix로 쓸 수 있음

```scala
// generic type inference
Array(1,2) == Array[Int](1,2)
Array[Int].apply(1,2,3) // invalid

// calling with non-function is equal to call apply
notFunction(123)
notFunction.apply(123)

// equal can be replaced by update
greetStrings(0) = "Hello"
greetStrings.update(0, "Hello")
```

### List

- Array와 다른점
  - immutable (Array는 mutable)
  - 값 비교 가능 (Array는 reference 비교함)
  - 연결 리스트이므로, random access에 선형시간이 걸림
- 각 노드가 head와 tail을 가지고 이어진 연결리스트
  - `head`나 `tail`은 상수시간에 찾을 수 있다.
- 연산자 메서드 존재
  - `elem :: List` 리스트 가장 앞에 원소를 추가, $O(1)$
  - `List :+ elem` 리스트 뒤에 원소를 추가, $O(N)$
  - `List ::: List` 두 리스트를 이어붙임, $O(N)$
- `Nil`은 빈 리스트

### Tuple

- Array처럼 특별취급 되는 자료구조
- 괄호로 묶어서 선언 가능
- 실제로는 `TupleN` 클래스의 인스턴스
- decomposed binding 가능
- `_1`, `_2` 등으로 접근 가능

### Set, Map

- mutable, immutable 패키지가 나눠져있음, 양자택일 해야함
  - `scala.collection.immutable.HashSet`
  - `scala.collection.mutable.HashSet`
- 기본은 immutable임
- 원소 추가
  - `+=`는 mutable에서만 쓸 수 있음
  - `+`는 둘다 쓸수 있음, immutable에서는 새 Set을 만들어서 리턴
- Map의 경우는 `->` 메서드로 튜플을 만들어 선언, 그냥 튜플 넣어도 됨
  - `Map((1,'a'), (2,'b')) == Map(1->'a', 2->'b')`
- Map, Set 모두 List 처럼 동일성 비교 가능


# Classes and Objects

# Basic Types and Operations

# Function Objects

# Built-in Control Structures

# Function and Closures

# Composition and Inherithance

# Scala's Hirarchy

# Traits

# Packages and Imports

# Assertions and Unit Testing

# Case Classes and Pattern Matching

# Working with Lists

# Collections

# Statful Objects

# Type Parameterization

# Abstract Member

# Implicit Conversions and Parameters

# Implementing Lists

# For Expressions Revisited

# Extractors

# Annotations

# Objects As Modules

# Object Equality

# Combining Scala and Java

# Actor and Concurrency

# Combinator Parsing

