---
layout: post
category: development
title: Kotlin in Action 정리
tags: [Kotlin]
---

# Kotlin: what and why

### Kotlin's primary traits

- Target: 서버, 안드로이드, JVM
- 타임 추론을 바탕으로 한 정적 타입
- Functional, OOP 둘다 지원
- 자바 코드 쉽게 활용 가능

### 코틀린 설계 철학

- Pragmatic 실용적인
  - 프로덕션 용이고, 다른 언어들에서 가져온 익숙한 기능들을 도입
  - 특정 프로그래밍 패러다임을 강요하지 않음
  - IDE 제공
- Concise 간략한
  - Boilerplate 제거, 풍부한 라이브러리 제공
  - 람다 제공, 특수문자 연산자 오버로딩 미제공
- Safe 안전한
  - JVM 위이므로, 타입사용, 동적 메모리 관리 면에서 안전함
  - null을 명시적으로 표현, 컴파일 시에 null에러 조기 차단
  - 런타임 타입 체크가 더 값싸고, 쉽게 가능
- Interoperable 상호 운용 가능한
  - Java-to-Kotlin 정적 변환, 자동 리펙토링 가능
  - Java의 라이브러리 활용 그대로 가능
  - Collections 라이브러리는 자바에 완전 의존

### 코틀린 툴 사용

- `kotlinc`로 컴파일, `kt`파일을 `class`로 변환
  - 컴파일 시, 의존성 지닌 jar을 포함시함
- 실제 프로젝트에서는 Maven, Gradle, Ant 등의 빌드 툴을 사용함


# Kotlin Basics

### 기초 요소들: 함수

```kotlin
// 함수, 인자, 리턴 없음
fun main(args: Array<String>) {}

// 함수, 인자, 리턴있음, 삼항연산자, Block Body
fun max(a: Int, b: Int): Int {
  return if (a > b) a else b
}

// Expression Body
fun max(a: Int, b: Int): Int = if (a > b) a else b
// Expression Body, omit return type
fun max(a: Int, b: Int) = if (a > b) a else b
```

### 기초 요소들: val, var

```kotlin
// immutable reference variable
val answer = 42
val answer: Int = 42
val yearsToCompute = 7.5e6

// immutable reference, 리스트 객체에 요소 추가는 가능
val languages = arrayListOf("Java")
languages.add("Kotlin")

// 재할당이 불가능한 것이기 때문에, 선언과 첫 할당의 분리가 가능
val answer: Int
answer = 42

// 단 한번만 할당되는것이 분명하다면, control flow에 따른 분리 가능
val message: String
if (canPerformOperation()) { message = "Success" }
else { message = "Failed" }
```

### string template

```kotlin
val name = "Kotlin"
// string template with variable
println("Hello, $name!")
// string template with expression
println("Hello, ${args[0]}!")
```

### Classes and properties

- Java에서는 private 변수에 getter와 setter를 선언해 사용
- Kotlin에서는 property에 기본적으로 getter setter가 선언됨
  - 필요하면 getter, setter 바꿔서 선언할 수 있음
- backing field: 프로퍼티뒤에 숨겨진 필드
  - Kotlin에서는 필드에 직접 접근이 불가능함(프로퍼티는 필드가 아님)
  - setter에서 값을 대입할 때, `field` 를 통해서 backing field에 대입

```kotlin
// 반복적인 생성자 축약 + 프로퍼티 선언
class Person(
  val name: String,
  var isMarried: Boolean
)

// custom accessor, not using backing field
class Rectangle(val height: Int, val width: Int) {
  val isSquare: Boolean
    get() = height == width
}
```

### 디렉토리, 패키지 관리

- 클래스 별로 파일을 나누는 java
- Kotlin에서는 꼭 그럴필요는 없음
  - 패키지를 하나의 파일로 해도 되고
  - 패키지를 폴더로 만들어도 무방하다.

### when과 enum

- `enum class`: Java enum의 확장
  - `enum class`는 프로퍼티를 가질 수 있음
  - `enum class`의 첫 문장으로 enum constant선언 가능
  - constant 선언 후에 세미콜론 찍어야함(Kotlin 내 유일한 세미콜론 사용)
  - 세미 콜론 이후에 멤버 함수를 선언 가능
- `when`: switch의 확장
  - 조건과 결과가 `->`로 대응되어서 나열됨
  - 각 조건 끝에 세미콜론이 생략된 것이라 생각하는게 편함
  - Block으로 나눠서 문장을 실행할 수도 있음
  - 그 자체를 Expression으로 만들어 값을 반환하게 할 수도 있음
    - block으로 묶은경우, 마지막줄에 값을 써줘야함
  - When에 argument를 준 경우 다음과 같은 형태가 가능
    - `값 -> 값 or {문장}`
    - `값 -> 값 or {문장}`
    - `값,값 -> 값 or {문장}`
    - `ArbitaryObject -> 값 or {문장}`
    - `is Type -> 값 or {문장}`
    - `else -> 값 or {문장}`
  - When에 argument를 주지 않은 경우
    - `Boolean -> 값 or {문장}`

### Smart cast

- 타입 캐스팅은 `as`, 타입체크는 `is`
- explicit casting: `e as Num`
- smart casting: `if (e is Sum) { return e.right }`
  - 타입을 체크한 이후에는 캐스팅이 필요없다.
  - 값이 변하는 경우는 스마트 캐스팅을 적용할 수 없다.
- `when is Type` 구문에서도 스마트 캐스팅이 적용됨

### 반복문, in 연산자

- while은 Java랑 같음
- for는 range based만 있음
  - `in`연산자를 사용
  - `1..5`: 1, 2, 3, 4, 5
  - `1 until 5`: 1, 2, 3, 4
  - `1 until 5 step 2`: 1, 3
  - `5 downTo 1`: 5, 4, 3, 2, 1
  - `5 downTo 1 step 2`: 5, 3, 1
- map을 반복할 경우
  - `for ((k, v) in treeMap)` 
- `in` 연산자
  - 반복문 외에 포함을 체크할 때 사용 가능,
  - 문자: `c in 'a'..'z'`
  - 문자열: `"Kotlin" in "Java".."Scala"`

### 예외처리

- Java와 달리 new 필요없음, 호출할 예외 명시 필요 없음
- throw는 expression의 일부가 될 수 있음
- try를 expression으로 쓸 수 있음, 중괄호는 생략 불가
- try, catch, finally 사용 가능
- try-with-resource 구문은 없음

```kotlin
// throw as expression
val x = if (cond) 10 else throw Exception()

// try as expression
val number = try {
  Integer.parseInt(reader.readLine())
} catch (e: IOException) {
  null
} catch (e: NumberFormatException) {
  return
}
```


# Defining and calling functions

### 함수 호출을 더 쉽게 만드는 기능들

- Named arguments
  - 단 Java7 이전 코드들에서는 지원 안됨
- Default parameters
  - overloading 수를 줄여줌
  - 기본 인자는 Callee에 포함됨. 빌드시에 유의할 것
- `@JvmOverloaded`
  - Java에서 호출하기 위해, 모든 가능한 Signature를 오버로딩 해줌
  - Default param 지정시 개수만큼 오버로딩된 함수가 생김
- 최상위 함수
  - 함수를 최상위(package 아래) 레벨에 class 없이 선언할 수 있음
  - 컴파일시 파일 이름 클래스가 자동생성(`join.kt` = `class JoinKt`)
  - Java에서 import시 Filename class를 써줘야함
- 최상위 property
  - Java에서 getter/setter로 접근 가능
  - `const`로 선언시, Java에서 `static final` 취급, 직접 접근 가능

### Extension functions

- 기존 라이브러리에 함수 및 프로퍼티 추가 가능
  - Java나 다른 JVM 코드(java class로 컴파일 가능한)도 확장 가능
  - 확장 대상을 Reciever type이라고 함
- 명시적 import가 필요
  - extension 자체를 명시적으로 import 해야함
  - Reciever를 import와 무관
  - (참고) `as`로 import된 대상의 이름 변경 가능
- 가시성이 제한됨
  - private, protected 멤버는 접근 불가
  - 다른 extension function은 호출 가능
- Java에서는 Reciever를 첫 인자로 받는 정적함수로 취급됨
- Java에서의 Util함수를 extension으로 사용하면 유용함
  - Util함수는 상태를 저장하지 않는 함수들
- 오버로딩이 불가능함
  - 실제로는 정적함수에 불과함
  - 즉 런타임 타입에 무관하게, 컴파일 타임에 호출될 함수가 결정됨
  - 멤버 함수와 충돌시, 무조건 멤버함수가 우선시됨

```kotlin
// Java 클래스의 확장
fun String.lastChar(): Char = this.get(this.length - 1)

// 위 코드와 같음 (this 없이 사용)
fun String.lastChar(): Char = get(length - 1)

// Java
char c = StringUtilKt.lastChar("Java");
```

### Extension properties

- 상태를 가지지 않는 조건 하에서 확장 가능
- Java 코드 상으로는 정적 getter/setter가 추가되는 것
- getter가 무조건 있어야함 (backing field가 없으므로)
- `val`로 선언하면, getter만 있으면 됨
- `var`로 선언하면, getter/setter 둘다 있어야함 

```kotlin
var StringBuilder.lastChar: Char
  get() = get(length - 1)
  set(value: Char) {
    this.setCharAt(length - 1, value)
  }

// in java
StringUtilKt.getLastChar("Java")
```

### Java Collections 확장과 그 원리들

- Java에 비해 Collections의 함수가 확장되어 있음
  - Factory: `hashSetOf, arrayListOf, hashMapOf`
  - Utility: `last(), max()`
- 가변 인자 `vararg`
  - Java의 `int...` 대신 타입 앞에 `vararg` 붙임
  - `*args`: 리스트를 가변인자로 이용 가능
  - Collection의 생성자들에 사용
- map 선언시의 `to` 
  - `1.to("one")` == `1 to "one"`
  - infix로 선언된 함수는 위 표기 가능
- destructuring declaration
  - C++에서의 unstructured binding
  - `component1()` 등의 형태로 선언된 메소드가 있으면 사용 가능

```kotlin
// 가변 인자 선언
fun listOf<T>(vararg values: T): List<T> { ... }

// 리스트 확장 가번 인자
val list = listOf("args: ", *args)

// infix 함수 예시
infix fun Any.to(other: Any) = Pair(this, other)
val map = mapOf(1 to "one", 7 to "seven")

// destructuring declaration
val name = person.component1()
val age = person.component2()
val (name, age) = person
```

### 정규식 및 문자열 처리

- 정규식 타입 따로 존재
  - Java는 정규식 타입이 따로 없어서 매우 혼란스러움
  - Kotlin은 정규식 타입이 따로 존재, `String.toRegex`로 생성
- 정규식 타입의 기능들
  - match, find등 일반적 컨셉 제공
  - `destructured`를 통해서 분리 선언 가능
- `"""`: 여러줄 문자열
  - `trimMargin(".")`: 들여쓰기 처리
  - escape 문자는 지원 안함
  - string template은 가능
  
```kotlin
// java split with regex
"12.3-4".split("[.]") == ["12", "3-4"]
"12.3-4".split(".") == []

// kotlin
"12.34".split(".") == ["12", "3-4"]
"12.34".split(".", "-") == ["12", "3", "4"]
"12.3-4".split("[.-]".toRegex()) == ["12", "3", "4"]

// kotlin regex, match, destructed
val matchResult = regex.matchEntire(path)
val (directory, filename, extension) = matchResult.destructured
```

### 로컬 함수 및 클로저

- 함수 내에서 함수를 선언하는것이 허용됨
- 클로저 역시 지원함, 람다/로컬함수 내에서 변수를 수정하는게 가능


# Classes, objects, and interfaces

### Interface

- Java8과 유사
- 함수들은 `open`이 기본, 구현체에서 `overide` 필요
- 인터페이스 default 함수 사용 가능
  - `default` 키워드 필요 없음
  - 다중 상속 충돌 시 컴파일 에러 - 명시적 선언 필요

```kotlin
interface Clickable {
  fun click() // 추상 메소드
  fun showOff() = println("I'm clickable!") // 디폴트 메소드
}

// 구현시에 콜론(:) 사용
class Button : Clickable, Focusable {
  override fun click() = println("I was clicked")

  // 명시적 충돌 해소, super의 사용법
  override fun showOff() {
    super<Clickable>.showOff()
    super<Focusable>.showOff()
  }
}
```

### Class

- 제어자: `final`이 기본, `open`은 명시적으로 부여
  - 자바의 경우는 `open`이 기본
  - `open class`: 상속 가능
  - `abstract class`: 인스턴스화 불가능
  - `open fun`: override 가능
  - `override fun`: overriding 함수, open으로 간주
  - `final override fun`: overriding 함수, 명시적 final 부여
  - `abstract fun`: subclass에서 구현이 강제됨, open으로 간주
- 접근 제어자: `public` 기본
  - 자바의 경우는 package-priaate가 기본
  - Kotlin은 package 대신 module을 접근 제어의 단위로 사용
- class 접근 제어
  - `public class`: 전체 공개
  - `internal class`: 모듈 내 공개
  - `private class`: 파일 내 공개
- 멤버 함수 접근 제어
  - `public member`: 전체 공개
  - `internal member`: 모듈 내 공개
  - `protected member`: 서브클래스에 공개, 자바와 달리 package내 공개 아님
  - `private member`: 클래스 내 공개

### inner, nested, sealed class

- inner vs nested class
  - Kotlin은 Serialize문제를 피하기 위해 nested class를 기본값으로 씀
  - inner 클래스가 가진 Outer 인스턴스 참조가 Serialize에 문제를 일으킴
- sealed class
  - enum 대신, 클래스 계층 구조를 when(switch) 구문의 인자로 쓰게 해줌
  - nested class 대상이 제한(sealed)됨
  - 컴파일러가 `else`의 빠짐을 체크하는 등 실수를 줄여줌

```kotlin
class Outer {
  // outer 인스턴스 접근 가능
  class InnerClass // Java
  inner class InnerClass // Kotlin

  // outer 인스턴스 접근 불가
  static class NestedClass // Java
  class NestedClass // Kotlin
}