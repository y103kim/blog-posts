---
layout: post
category: development
title: Kotlin in Action 정리
tags: [Kotlin]
---

# Chapter 1 Kotlin: what and why

### Kotlin's primary traits

- Target: 서버, 안드로이드, JVM
- 타임 추론을 바탕으로 한 정적 타입
- Functional, OOP 둘다 지원
- 오픈소스, 공짜
- 어플리케이션으로서 장점
    - 기존 자바 코드 활용 쉬움
    - DSL로서 활용하기도 쉬움
    - 성능 감소 없이, 더 짧고 간략한 코드 작성

### 코틀린 설계 철학

- Pragmatic 실용적인
  - 프로덕션 용이고, 다른 언어들에서 가져온 익숙한 기능들을 도입
  - 특정 프로그래밍 패러다임을 강요하지 않음
  - IDE 제공
- Concise 간략한
  - Boilerplate 제거, 풍부한 라이브러리 제공
  - 람다 제공, 특수문자 연산자 오버로딩 미제공
- Safe 안전한
  - JVM 위이므로, 타입사용, 동적 메모리 관리 면에서 안전함
  - null을 명시적으로 표현, 컴파일 시에 null에러 조기 차단
  - 런타임 타입 체크가 더 값싸고, 쉽게 가능
- Interoperable 상호 운용 가능한
  - Java-to-Kotlin 정적 변환, 자동 리펙토링 가능
  - Java의 라이브러리 활용 그대로 가능
  - Collections 라이브러리는 자바에 완전 의존

### 코틀린 툴 사용

- `kotlinc`로 컴파일, `kt`파일을 `class`로 변환
  - 컴파일 시, 의존성 지닌 jar을 포함시함
- 실제 프로젝트에서는 Maven, Gradle, Ant 등의 빌드 툴을 사용함

# Chapter 2 Kotlin Basics

### 기초 요소들: 함수

```kotlin
// 함수, 인자, 리턴 없음
fun main(args: Array<String>) {}

// 함수, 인자, 리턴있음, 삼항연산자, Block Body
fun max(a: Int, b: Int): Int {
  return if (a > b) a else b
}

// Expression Body
fun max(a: Int, b: Int): Int = if (a > b) a else b
// Expression Body, omit return type
fun max(a: Int, b: Int) = if (a > b) a else b
```

### 기초 요소들: val, var

```kotlin
// immutable reference variable
val answer = 42
val answerL Int = 42
val yearsToCompute = 7.5e6

// immutable reference, 리스트 객체에 요소 추가는 가능
val languages = arrayListOf("Java")
languages.add("Kotlin")

// 재할당이 불가능한 것이기 때문에, 선언과 첫 할당의 분리가 가능
val answer: Int
answer = 42

// 단 한번만 할당되는것이 분명하다면, control flow에 따른 분리 가능
val message: String
if (canPerformOperation()) { message = "Success" }
else { message = "Failed" }
```

### string template

```kotlin
val name = "Kotlin"
// string template with variable
println("Hello, $name!")
// string template with expression
println("Hello, ${args[0]}!")
```

### Classes and properties

- Java에서는 private 변수에 getter와 setter를 선언해 사용
- Kotlin에서는 property에 기본적으로 getter setter가 선언됨
  - 필요하면 getter, setter 바꿔서 선언할 수 있음
- backing field: 프로퍼티뒤에 숨겨진 필드
  - Kotlin에서는 필드에 직접 접근이 불가능함
  - 프로퍼티는 필드가 아님
  - setter에서 값을 대입할 때, `field` 를 통해서 backing field에 대입

```kotlin
// 반복적인 생성자 축약 + 프로퍼티 선언
class Person(
  val name: String,
  var isMarried: Boolean
)

// custom accessor, not using backing field
class Rectangle(val height: Int, val width: Int) {
  val isSquare: Boolean
    get() = height == width
}
```

### 디렉토리, 패키지 관리

- 클래스 별로 파일을 나누는 java
- Kotlin에서는 꼭 그럴필요는 없음
  - 패키지를 하나의 파일로 해도 되고
  - 패키지를 폴더로 만들어도 무방하다.

### when과 enum

Java `enum`보다 더 확장된 형태의 `enum class` 사용 가능

- `enum class`는 프로퍼티를 가질 수 있음
- `enum class`의 첫 문장으로 enum constant선언 가능
- constant 선언 후에 세미콜론 찍어야함(Kotlin 내 유일한 세미콜론 사용)
- 세미 콜론 이후에 멤버 함수를 선언 가능

Java `switch`보다 더 강략한 `when`

- 조건과 결과가 `->`로 대응되어서 나열됨
- 각 조건 끝에 세미콜론이 생략된 것이라 생각하는게 편함
- Block으로 나눠서 문장을 실행할 수도 있음
- 그 자체를 Expression으로 만들어 값을 반환하게 할 수도 있음
  - block으로 묶은경우, 마지막줄에 값을 써줘야함
- When에 argument를 준 경우 다음과 같은 형태가 가능
  - `값 -> 값 or {문장}`
  - `값 -> 값 or {문장}`
  - `값,값 -> 값 or {문장}`
  - `ArbitaryObject -> 값 or {문장}`
  - `is Type -> 값 or {문장}`
  - `else -> 값 or {문장}`
- When에 argument를 주지 않은 경우
  - `Boolean -> 값 or {문장}`

### Smart cast

- 타입 캐스팅은 `as`, 타입체크는 `is`
- explicit casting: `e as Num`
- smart casting: `if (e is Sum) { return e.right }`
  - 타입을 체크한 이후에는 캐스팅이 필요없다.
  - 값이 변하는 경우는 스마트 캐스팅을 적용할 수 없다.
- `when is Type` 구문에서도 스마트 캐스팅이 적용됨


### 반복문

- while은 Java랑 같음
- for는 range based만 있음
  - `in`연산자를 사용
  - `1..5`: 1, 2, 3, 4, 5
  - `1 until 5`: 1, 2, 3, 4
  - `1 until 5 step 2`: 1, 3
  - `5 downTo 1`: 5, 4, 3, 2, 1
  - `5 downTo 1 step 2`: 5, 3, 1
- map을 반복할 경우
  - `for ((k, v) in treeMap)` 

### in 연산자

- 반복문 외에 포함을 체크할 때 사용 가능
- 숫자, 문자, 문자열 등 크기를 따질 수 있는 모든것들에 가능
  - `c in 'a'..'z'`
  - `"Kotlin" in "Java".."Scala"`

### 예외처리

- Java와 달리 new 필요없음, 호출할 예외 명시 필요 없음
- throw는 expression의 일부가 될 수 있음
- try를 expression으로 쓸 수 있음, 중괄호는 생략 불가
- try, catch, finally 사용 가능
- try-with-resource 구문은 없음

```kotlin
// throw as expression
val x = if (cond) 10 else throw Exception()

// try as expression
val number = try {
  Integer.parseInt(reader.readLine())
} catch (e: IOException) {
  null
} catch (e: NumberFormatException) {
  return
}
```