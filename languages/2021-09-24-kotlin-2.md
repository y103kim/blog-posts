---
layout: post
category: development
title: Kotlin in Action 정리 (2)
tags: [Kotlin]
---

# Operator overloading and other conventions

- 함수를 통해서 연산자 오버로딩
  - `operator fun times`
- 확장으로도 가능 
  - `operator fun Char.times(count: Int)`
- Nullable 타입에 대해서도 적용 가능(equal 제외)

### 산술 연산자

- binary 연산자
  - times, div, mod, plus, minus
  - 비트연산자는 기호 없음
- coumpound assignment 연산자
  - timesAssign, divAssign, modAssign, plusAssign, minusAssign
- unary 연산자
  - unaryPlus, unaryMinus, not, inc, dec
  - 전치, 후치 증감 연산(inc, dec) 정상적으로 진행됨 

```kotlin
// binary
operator fun Point.plus(other: Point): Point

// compound
operator fun Point.plusAssign(other: Point)

// unary
operator fun Point.inc()
```

### 비교 연산자

- 동치 비교 연산자
  - `a == b`를 `a?.equals(b) ?: (b == null)`로 연산함
  - null도 동치를 비교해야하기 때문
  - 그러므로 equal은 nullable type에 대해서 적용 불가
  - 레퍼런스를 비교하는 `===`는 오버로딩 불가
  - 오버로딩 시 `override`를 써야함, `Any` 클래스에 이미 정의되어 있기 때문
- 순서 비교 연산자
  - 비교가 가능하려면 `Comparable`을 상속받아야함
  - `a >= b` -> `a.compareTo(b) >= 0`
  - 위의 식은 Comparator의 정의를 기가막히게 보여주는 식이라고 생각함
  - `co

```kotlin
// equals
override fun equals(obj: Any?): Boolean

// compareTo
class Person(
  val firstName: String, val lastName: String
) : Comparable<Person> {
  override fun compareTo(other: Person): Int = 
    compareValuesBy(this, other, Person::lastName, Person::firstName)
}
```

### 기타 연산자 혹은 Convention 들

- 접근 연산자: get, set: `x[a, b] = c` -> `x.set(a, b, c)`
- 포함 연산자: contains: `a in c` -> `c.contains(a)`
- 범위 연산자: rangeTo: `start..end` -> `start.rangeTo(end)`
- 순회 연산자: Iterator
  - 인터페이스 `Iterator` 를 구현한 객체를 리턴해야 함
  - `hasNext`, `next` 두 함수를 구현해야함
- 구조 분해 선언
  - `component1`, `component2` 등을 선언해주어야 함
  - array나 collection, data class에는 이미 선언되어 있음

```kotlin
// 접근 연산자
operator fun Point.get(index: Int): Int
operator fun MutablePoint.set(index: Int, value: Int)

// 포함 연산자
operator fun Rectangle.contains(p: Point): Boolean
```

### delegated properties

- `by`를 통해서 프로퍼티를 위임할 수 있음
- 프로퍼티 산출이 복잡하거나, 가능하면 늦게 계산하고 싶다거나 할때 유용함
- 위임을 담당하는 객체는 복잡한 상태를 소유할수도 있음
- 프로퍼티 리스트를 map으로 보관하는 등의 응용도 가능

```kotlin
import kotlin.reflect.KProperty

class Delegate {
    operator fun getValue(thisRef: Any?, property: KProperty<*>): String { }

    operator fun setValue(thisRef: Any?, property: KProperty<*>, value: String) { }
}

class Foo {
  var p: Type by Delegate()
}
```

# Higher-order functions

- HOF: 람다를 파라미터로 받거나 리턴
- Function Type: `(T, U) -> R`
  - 자체로 Null이 될수 있음 `((T, U) -> R)?`
  - 인자로 받는 경우, 기본 인자를 람다로 줄 수 있다.

### inline functions

- inline 함수
  - 기존 다른 언어들에서와 의미가 같음
  - 람다를 인자로 받으면 그 람다까지도 inline
  - `noinline`을 붙이면 특정 람다는 인라인 시키지 않을 수 있음
  - inline된 람다에서는 외부 함수에 대한 리턴이 가능함
- inline과 generic
  - generic과 함께 쓸 때 타입이 전달되지 않음 (함수이므로)
  - 단 파라미터화 타입에 `reified`를 붙일경우 inline시에 타입 전달됨
- inline과 최적화
  - collection의 `filter`함수 등은 인라인 되어서 성능 이득을 봄
  - 코드 사이즈 증가에 대해 주의할 것
- inline과 resource
  - python의 with, java의 try-with-resource처럼 활용 가능
  - 락을 잡고 풀어줘야할때 이를 인라인 안에 숨기고, 내부 로직만 집중 가능

```kotlin
val l: Lock = ...
l.withLock {
  // access the resource protected by this lock
}
```

### HOF control flow

- labeled 리턴
  - 람다에 대한 리턴인지, 외부 함수에 대한 리턴인지 라벨로 지정
  - 라벨 안붙이고, 함수 이름으로도 가능
- 단 람다가 아니고 익명함수를 선언한 경우는 labeled 리턴 불가능함

```kotlin
// labeled return
people.forEach label@{
  if (it.name == "Alice") return@label
}

// labeled return with function name
people.forEach {
  if (it.name == "Alice") return@forEach
}
```